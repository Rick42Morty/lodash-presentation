<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>LoDash for RSS</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<style>
		.hljs.custom {
			font-size: 16px;
			line-height: 24px;
		}

		.hljs.large.code {
			font-size: 36px;
			line-height: 40px;
		}


		.left.small {
			text-align: left;
			font-size: 20px;
		}

		.small-list>li {
			font-size: 34px;
		}

		p.medium {
			font-size: 26px;
		}
	</style>

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h1>_.Lodash</h1>
				<h3>for Rolling Scopes School</h3>
				<p><br> by Yarotski Yauheni</p>
				<aside class="notes">
					Hi, everyone! My name is Eugene, and today we’ll talk about LoDash library
				</aside>
			</section>			
			<section>
				<h2>Plan</h2>
				<ol>
					<li class="fragment">What is Lodash?</li>
					<li class="fragment">Why should you use Lodash?</li>
					<li class="fragment">Adding Lodash to a project</li>
					<li class="fragment">Usage examples</li>
				</ol>
			<aside class="notes">
				Here’s the plan of my presentation
1. First, we’ll find out what Lodash is.
2. Then, we’ll answer the question Why should you use Lodash?
3. After that, we’ll learn about different ways of Adding Lodash to your project.
4. And finally, we’ll look at some Lodash usage examples
			</aside>
			</section>
			<section>
				<h2>What is Lodash?</h2>
				<p>A modern JavaScript utility library delivering modularity, performance & extras.</p>
				<ul>
					<li>Initiall release - April 23, 2012</li>
					<li>Almost 16 millions weekly npm downloads</li>
					<li>Almost 80k npm dependents</li>
					<li>More than 36k stars on GitHub</li>
					<li>Full build - only 24kB gzipped</li>
				</ul>
				<aside class="notes">
					So, What is Lodash?
It’s a modern JavaScript utility library delivering modularity, performance & extras.
It was initially released in 2012, so it’s already 6 years old.
As you can see, it has almost 16 millions weekly npm downloads and almost 80 thousands npm dependents. It’s one of the most depended on libraries in JS. It means that although you may have never dealt with Lodash library itself, you are probably using it indirectly all the time.
And it has more than 36ooo stars on GitHub, people obviously love it.
It’s full build version will take only 24kB of memory space.
OK, we’ve figured out that LoDash is a mature js library, extremely popular and light-weight.
				</aside>
			</section>
			<section>
				<h2>Why should you use Lodash?</h2>
				<ul class="small-list">
					<li class="fragment">It's more performant than anything you are going to write</li>
					<li class="fragment">It's more readable than anything you are going to write</li>
					<li class="fragment">It's a lot more concise than anything you are going to write</li>
					<li class="fragment">It's supported in all browsers, even really old ones</li>
					<li class="fragment">It helps you solve your problems while keeping your code semantic and DRY</li>
				</ul>
				<aside class="notes">
					So, why should you use Lodash?
Well, it's more performant than anything you are going to write
It's more readable than anything you are going to write
It's a lot more concise than anything you are going to write
It's supported in all browsers and environments, even really old ones
It helps you solve your problems while keeping your code semantic and DRY (which stands for don’t repeat yourself principle)
So, why don’t we check it out?
				</aside>
			</section>
			<section>
				<p>Adding Lodash to a project</p>
				<p class="left small">In a browser:</p>
				<pre><code class="hljs custom" data-trim>
								<script src="lodash.js"></script>								
								<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.11/lodash.min.js"></script>
						</code></pre>
				<p class="left small">Using npm:</p>
				<pre><code class="hljs custom" data-trim>
 $ npm i -g npm
 $ npm i --save lodash
						</code></pre>
				<p class="left small">In Node.js:</p>
				<pre><code class="hljs custom" data-trim>
// Load the full build.
var _ = require('lodash');

// Load the core build.
var _ = require('lodash/core');

// Load the FP build for immutable auto-curried iteratee-first data-last methods.
var fp = require('lodash/fp'); 

// Load method categories.
var array = require('lodash/array');
var object = require('lodash/fp/object');
					</code></pre>
					<aside class="notes">
						At first, let us learn about different ways of Adding Lodash to your project.
You can add it in a browser by inserting the script tag in your html. You can either use link to the files on your host, or you can use the cdn version.
You can install it with npm just like we install everything with npm.
And, In Node.js you can add Lodash like this. As you can see, there are a lot of options. You can require the whole library, or, for example only the module, that contains functions for working with Arrays, or you can even require just one function you need.
By the way, you can also use a cdn link to get a particular module or function, just like with Node.
					</aside>
			</section>
			<section>
				<h3>Awesome <a href="https://lodash.com/docs/4.17.11">Documentation</a></h3>
				<p>Array, Collection, Date, Function, Lang, Math, Number, Object, Seq, String, Util, Properties, Methods</p>
				<pre><code class="hljs large code" data-trim>
						_.funcName(argument, iteratee)
				</code></pre>				
				<p><br> Main function families: <br>
					is*,    stub*,    to*,   *By,   *In,  sorted*, <br>
					 *Depth,   *Right,   *With,   *While

				</p>
				<aside class="notes">
					Lodash library has really Awesome Documentation. It’s well-structured and has lots of examples, it’s divided into next sections:
Array, Collection, Date, Function, Lang, Math, Number, Object, Seq, String, Util, Properties, Methods
I’ve watched several YouTube tutorials on Lodash, and in most cases it’s easier and faster to just check out the documentation, to find out what a particular function actually does.
In most cases, Lodash functions are used like this:
_.funcName(argument, iteratee)
Of course, there are too many functions in Lodash for a usual man to remember, but in most cases function names are pretty straightforward, and we can say, there are several function families, grouped according to some similar logic:
For example, isSmth checks if the argument is Smth, sorted* functions are optimized for working with sorted Arrays, and *Depth functions can control the depth of some recursive operations.
				</aside>
			</section>
			<section>
				<p>Array methods</p>
				<p class="medium">fill, concat, pull, join, slice, sum, max, min, mean, ...</p>
				<p class="left small">_.compact(array)</p>
				<pre><code class="hljs custom" data-trim>
_.compact([5, 0, undefined, NaN, 16, 'Rick', null, false, 2, '', 3]);
// => [5, 16, "Rick", 2, 3]		
						</code></pre>
				<p class="left small">_.take(array, [n=1]) / _.takeRight(array, [n=1])</p>
				<pre><code class="hljs custom" data-trim>
								_.take([1, 2, 3, 8, 5]);
								// => [1]								 
								_.take([1, 2, 3, 8, 5], 2);
								// => [1, 2]

								_.takeRight([1, 2, 3, 8, 5]);
								// => [5]								 
								_.takeRight([1, 2, 3, 8, 5], 3);
								// => [3, 8, 5]										
						</code></pre>
				<p class="left small">_.flattenDeep(array)</p>
				<pre><code class="hljs custom" data-trim>
								_.flattenDeep([1, [2, [3, [4]], 5]]);
								// => [1, 2, 3, 4, 5]				
						</code></pre>
						<aside class="notes">
							Now, let us look at some Array methods.
You may have already noticed, that Lodash duplicates a lot of methods, that most browsers already understand without Lodash, such as forEach, map, filter, etc. In most cases, Lodash equivalents were created earlier, and their current implementations are pretty smart. If Lodash notices, that browser already has some function, it lets browser implementation of this function do the job, otherwise, it uses its own implementation.
Here are some Array methods I find useful:
_.compact method removes all the faulty values from an array
_take method creates a slice of array with n elements taken from the beginning. There’s also takeRight method, that takes the elements from the end of an array.
_.flattenDeep method recursively flattens array.
						</aside>
			</section>
			<section>
				<p>Object methods</p>
				<p class="medium">assign, at, keys, forIn, keys, values, ...</p>
				<p class="left small">Object manipulation</p>
				<pre><code class="hljs custom" data-trim>
								var item = {"a":{"b":{"c":3}}};
 
								_.get(item, 'a.b.c', 3);
								// → 3
								
								_.set(item, 'a.b.c', 5);
								// → {"a":{"b":{"c":5}}}
								
								_.has(item, 'a.b.c.d');
							 // → false
								 
				</code></pre>
				<p class="left small">_.fromPairs(pairs)</p>
				<pre><code class="hljs custom" data-trim>
						_.fromPairs([['a', 1], ['b', 2]]);
						// => { 'a': 1, 'b': 2 }								 
				</code></pre>
			</code></pre>
			<p class="left small">_.toPairs(object)</p>
			<pre><code class="hljs custom" data-trim>
					_.toPairs([{ 'a': 1, 'b': 2 }]);
					// => [['a', 1], ['b', 2]]								 
			</code></pre>
			<aside class="notes">
				Here are some Object methods.
We can perform object manipulation with get and set functions, which speak for themselves, and we can check if an object has some property with has function.
There is also toPairs function, that can turn an object into an array of pairs, and fromPairs function, that turns this array back into object
			</aside>
			</section>
			<section>
					<p>Collection methods</p>
					<p class="medium">map, reduce, filter, some, every, forEach (aka each), size, ...</p>
					<p class="left small">_.sortBy( )</p>
				<pre><code class="hljs custom" data-trim>
var users = [
  { 'user': 'fred',   'age': 48 },
  { 'user': 'barney', 'age': 36 },
  { 'user': 'fred',   'age': 40 },
  { 'user': 'barney', 'age': 34 } ]
 
_.sortBy(users, [ o => o.user ]);
// => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]

_.sortBy(users, 'age');
// => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 
_.sortBy(users, ['user', 'age']);
// => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
					</code></pre>
					<p class="left small">_.size(collection)</p>
				<pre><code class="hljs custom" data-trim>
						_.size([1, 2, 3]);			        // => 3						 
						_.size({ 'a': 1, 'b': 2 });			// => 2						 
						_.size('pebbles');				// => 7
				</code></pre>
				<aside class="notes">
					Here are some Collection methods.
sortBy method can sort collections with some specified function, with a key name, or even with several key names, in wich case it performs a sort like SQL would do it.
size method returns the length of an array, object or string
				</aside>
			</section>
			<section>
				<p>Strings and Numbers</p>
				<p class="medium">round, sum, multiply, camelCase, snakeCase, kebabCase, trim, pad, ...</p>
				<p class="left small">_.random([lower=0], [upper=1], [floating])</p>
				<pre><code class="hljs custom" data-trim>
						_.random(0, 5);
						// => an integer between 0 and 5
						_.random(5);
						// => also an integer between 0 and 5
						_.random(5, true);
						// => a floating-point number between 0 and 5
				</code></pre>
				<p class="left small">_.words([string=''], [pattern])</p>
				<pre><code class="hljs custom" data-trim>
_.words('fred, barney, & pebbles');
// => ['fred', 'barney', 'pebbles'] 
_.words('fred, barney, & pebbles', /[^, ]+/g);
// => ['fred', 'barney', '&', 'pebbles']
				</code></pre>
				<p class="left small">_.deburr([string=''])</p>
				<pre><code class="hljs custom" data-trim>
						_.deburr('déjà vu');
						// => 'deja vu'
				</code></pre>
				<aside class="notes">
					There are also a lot of methods for working with Strings and Numbers.
For example, a random method is a fast way of generating random data, words method turns a string into an array of words this string contains, and deburr method turns all the weird Latin latters into normal Latin letters.
				</aside>
			</section>
			<section>
					<p>Just a couple of methods I like</p>
				<p class="left small">_.cloneDeep( )</p>
				<pre><code class="hljs custom" data-trim>
							var original = { foo: "bar" };
							var copy = _.cloneDeep(original);

							copy.foo = "new value";

							// copy -> { foo: "new value" } 
							// original -> { foo: "bar" }  Yeah!							
					</code></pre>
				<p class="left small">_.times(n, [iteratee=_.identity])</p>
				<pre><code class="hljs custom" data-trim>
						_.times(3, String);
						// => ['0', '1', '2']
						
						_.times(10, Number)
						// => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

						_.times(8, () => _.random(100));
						// => [10, 0, 23, 2, 50, 57, 60, 36]
				</code></pre>
				<aside class="notes">
					Here is just a couple of methods I like.
With cloneDeep method, we can create an independent copy of an object. It means, that if you create a copy of an object with deepClone, and then change it somehow, it won’t take any effect on the original object.
And times method can run any function n times. I find it useful when I need to generate some data. As you can see in my examples, it’s really easy to generate a usual array, or an array, consisting of random numbers.
				</aside>
			</section>
			<section>
				<p>It's time for some chaining!</p>
				<pre><code class="hljs custom" data-trim>
					var users = [
						{ 'user': 'barney',  'age': 36 },
						{ 'user': 'fred',    'age': 40 },
						{ 'user': 'rick',    'age': 18 },
						{ 'user': 'pebbles', 'age': 11 }
					];

					// explicit chaining
					var youngest = _
					 .chain(users)
					 .sortBy('age')
					 .map( o => o.user + ' is ' + o.age )
					 .head()
					 .value();  // => 'pebbles is 11'
					</code></pre>
					<pre><code class="hljs custom" data-trim>
					// implicit chaining
					_(users)
					 .sortBy('age')
					 .map( o => o.user + ' is ' + o.age )
					 .head();  // => 'pebbles is 11'
				</code></pre>	
				<aside class="notes">
					And for desert let us have a look at couple chaining examples.
Let us assume that we want to get a string, telling us the name and the age of the youngest user in a collection of objects.
We can do it easily with the help of Lodash chain function. We can use it either explicitly, or implicitly. When doing it explicitly, we first need to wrap our collection of users with chain method. After that goes the series of Lodash functions, and we have to call value() method at the end of the chain, in order to actually get the result.
With implicit chaining syntax, we don’t need the chain keyword itself, and we also don’t need the value() at the end of the chain. We can just stop the chain of methods at any moment.
				</aside>			
			</section>
			<section>
				<p >Find sum of squares of three largest non-equal numbers in an arbitrarily nested array</p>
				<pre><code class="hljs custom" data-trim>
					const arr = [1, [7, 5, 2], [2, [3, [4]], 5], 17];	

					_.chain(arr)
					.flattenDeep()    // -> [1, 7, 5, 2, 2, 3, 4, 5, 17]
					.uniq()           // -> [1, 7, 5, 2, 3, 4, 17]
					.sortBy()         // -> [1, 2, 3, 4, 5, 7, 17]
					.takeRight(3)     // -> [5, 7, 17]
					.map(el => el*el) // -> [25, 49, 289]
					.sum()
					.value();         // -> 363
				</code></pre>
				<pre><code class="hljs custom" data-trim>
					_(arr)
					.flattenDeep()
					.uniq()
					.sortBy()
					.takeRight(3)
					.map(el => el*el)
					.sum();   // -> 363
				</code></pre>		
				<aside class="notes">
					Here is one more chaining example. Let us imagine that for some reason we need to find a sum of squares of three largest non-equal numbers in an arbitrarily nested array. Without Lodash, it would probably take me some time, and my code would be long and not very good-looking.
With Lodash, I just think about what should I do with the array, not about implementation of all the functions. OK, I guess I’ll flatten it first, then get rid of repeating values, sort it, take last three values of the sorted array, square them up, and then sum up the squares.
That’s it! Job is done! The code doesn’t even look like a code, it looks like a plan or a list of actions we are planning to do. I think that’s exactly what Lodash was made for.
Of course, Lodash deserves more than a 10 minutes talk, but that’s all we have today. I hope I’ve at least inspired you to look through Lodash docs once more.
				</aside>		
			</section>
			<section>
				<h2>thank you!</h2>
				<footer style='font-size: 28px;'><br><br><br> GitHub <a href="https://github.com/Rick42Morty">Rick42Morty</a> </footer>
				<aside class="notes">
					That’s all for today, thank you for your attention!
				</aside>
			</section>
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>